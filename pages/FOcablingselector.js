var JSONdata = {
   "ShapeName":["Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-8","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-24","Transceiver MPO-24","Transceiver MPO-4","Transceiver MPO-8","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-4","Transceiver MPO-8","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-16","Transceiver MPO-24","Transceiver MPO-32","Transceiver MPO-8","Transceiver MPO-8","Transceiver MPO-8","Transceiver Duplex LC","Transceiver Quad CS","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver Duplex LC","Transceiver MPO-8","Transceiver MPO-16","Transceiver MPO-8","Transceiver MPO-24","Transceiver MPO-24"],
   "PhysicalInterface":["LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MTP-12 or MTP-8","MPO-12","LC duplex","LC duplex","LC duplex","LC duplex","MPO-12","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-24","MPO-24","MPO-12","MPO-12","MPO-12","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-12","LC duplex","LC duplex","LC duplex","LC duplex","MPO-12","MPO-12","MPO-12","LC duplex","LC duplex","LC duplex","LC duplex","MPO-16","MPO-24","MPO-32","MPO-12","MPO-12","MPO-12","LC duplex","Quad CS","LC duplex","LC duplex","LC duplex","MPO-12","MPO-16","MPO-12","MPO-24","MPO-24"],
   "TotalSpeed":[10,25,25,25,100,40,40,40,40,40,40,40,40,40,50,50,50,50,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,200,200,200,200,200,200,200,400,400,400,400,400,400,400,400,400,400,400,800,800,128,120,150],
   "Technology":["10G-SR","25G-ER","25G-LR","25G-SR","25G-PSM","40G-LR4","40G-SR4","40G-eSR4","40G-SR2-BIDI","40G-ER4","40G-LX4","40G-LM4","40G-PLR4","40G-FR","50G-FR","50G-LR","50G-SR","50G-DR","100G-DR","100G-FR","100G-ER4","100G-LR4","100G-SR10","10x10G-SR","100G-SR2","100G-eSR4","100G-SR4","10x10G-FR","10x10G-LR","10x10G-ER","100G-SR2-Bidi","100G-SR1.2","100G-ZR","100G-PSM4","100G-CWDM4","100G-CWDM4 lite","100G-eCWDM4","100G-CLR4","200G-SR2","200G-SR4","200G-DR4","200G-FR4","200G-LR4","200G-ER4","200G-SR1.4","400G-SR8","400G-SR8.2","400G-SR16","400G-SR4.2-BIDI","400G-DR4","400G-XDR4","400G-FR4","400G-2FR4","400G-FR8","400G-LR8","400G-ER8","800G-SR4.4","800G-SR8","128GFC","12x10G","12x12.5G"],
   "Related":["10G-SR","25G-ER","25G-LR","25G-SR","25G-PSM","40G-LR4","40G-SR4;10G-SR","40G-SR4;10G-SR","40G-SR2-BIDI","40G-ER4","40G-LX4","40G-LM4","40G-PLR4","40G-FR","50G-FR","50G-LR","50G-SR","50G-DR","100G-DR","100G-FR","100G-ER4","40G-LM4","100G-SR10;10G-SR","10x10G-SR;10G-SR","100G-SR2;50G-SR","100G-eSR4;25G-eSR","100G-SR4;25G-SR","10x10G-FR","10x10G-LR","10x10G-ER","100G-SR2-Bidi","100G-SR1.2","100G-ZR","100G-PSM4;25G-PSM","100G-CWDM4","100G-CWDM4 lite","100G-eCWDM4","100G-CLR4","200G-SR2;100G-SR","200G-SR4;50G-SR","200G-DR4;50G-DR","200G-FR4","200G-LR4","200G-ER4","200G-SR1.4","400G-SR8;100G-SR4","400G-SR8.2;50G-SR","400G-SR16;100G-SR4","400G-SR4.2-BIDI","400G-DR4;100G-DR","400G-DR4;100G-FR","400G-FR4","400G-2FR4;200G-FR4;100G-CWDM4","400G-FR8","400G-LR8","400G-ER8","800G-SR4.4;200G-SR1.4","800G-SR8;200G-SR2","128GFC;32GFC","12x10G;10G-SR;40G-SR4","12x12.5G;10G-SR;40G-SR4"],
   "Quantity":["1","1","1","1","1","1","1;4","1;4","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1;10","1;10","1;2","1;4","1;4","1","1","1","1","1","1","1;4","1","1","1","1","1","1;4","1;4","1","1","1","1","1;2","1;8","1;4","1","1;4","1;4","1","1;2;2","1","1","1","1;4","1;4","1;4","1;12;3","1;12;3"],
   "Unique":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
   "Duplex":["Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Parallel","Parallel","Duplex","Duplex","Duplex","Duplex","Parallel","Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Parallel","Parallel","Parallel","Parallel","Parallel","Duplex","Duplex","Duplex","Duplex","Duplex","Duplex","Parallel","Duplex","Duplex","Duplex","Duplex","Parallel","Parallel","Parallel","Duplex","Duplex","Duplex","Duplex","Parallel","Parallel","Parallel","Parallel","Parallel","Parallel","Duplex","Parallel","Duplex","Duplex","Duplex","Parallel","Parallel","Parallel","Parallel","Parallel"],
   "ConnectorType":["LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-20","MPO-20","MPO-4","MPO-8","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","MPO-4","MPO-8","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","MPO-16","MPO-X6","MPO-32","MPO-8","MPO-8","MPO-8","LC duplex","CS-2","LC duplex","LC duplex","LC duplex","MPO-8","MPO-16","MPO-8","MPO-24","MPO-24"],
   "RelatedConnectorType":["LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8;LC duplex","MPO-8;LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-20;LC duplex","MPO-20;LC duplex","MPO-4;LC duplex","MPO-8;LC duplex","MPO-8;LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-8;LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-4;LC duplex","MPO-8;LC duplex","MPO-8;LC duplex","LC duplex","LC duplex","LC duplex","LC duplex","MPO-16;MPO-8","MPO-X6;LC duplex","MPO-32;MPO-8","MPO-8","MPO-8;LC duplex","MPO-8;LC duplex","LC duplex","CS-2;LC duplex;LC duplex","LC duplex","LC duplex","LC duplex","MPO-8;LC duplex","MPO-16;MPO-4","MPO-8;LC duplex","MPO-24;LC duplex;MPO-8","MPO-24;LC duplex;MPO-8"],
   "RelatedPolarityType":["AP","AP","AP","AP","AP","AP","B;NP","B;NP","AP","AP","AP","AP","B","AP","AP","AP","AP","AP","AP","AP","AP","AP","A:2-2;R1","A:2-2;R1","B;NP","B;NP","B;NP","AP","AP","AP","AP","AP","AP","B;NP","AP","AP","AP","AP","B;NP","B;NP","B;NP","AP","AP","AP","AP","B;XX","B:2-2;KK","B:2-2;TT","B","B;NP","B;NP","AP","EE;JJ;JJ","AP","AP","AP","B;NP","B;PP","B;NP","A:2-2;R1;YY","A:2-2;R1;YY"],
   "BreakoutOption":["","","","","","","4x 10G","4x 10G","","","","","4x 10G","","","","","","","","","","10x 10G","10x 10G","2x 50G-SR","4x 25G","4x 25G","","","","","","","4x 25G","","","","","","4x 50G-SR","4x 50G-DR?","","","","","2x 100G-SR4","8x 50G-SR","4x 100G-SR4","","4x 100G-DR","4x 100G-FR","","2x 200G-FR4\n2x 100G-CWDM4","","","","4x 200G-SR1.4","4x 200G-SR2","","12x 10G-SR\n3x 40G-SR4","12x 10G-SR\n3x 40G-SR4"],
   "NumberOfLanes":[1,1,1,1,1,4,4,4,1,4,1,1,4,1,1,1,1,1,1,1,4,4,10,10,2,4,4,10,10,10,4,4,4,4,4,4,4,4,2,4,4,4,4,4,1,8,8,16,4,4,4,4,8,8,8,8,4,8,4,12,12],
   "SingleLaneSpeed":["10G","25G","25G","25G","25G","10G","10G","10G","20G","10G","10G","10G","10G","40G","50G","50G","50G","50G","50G","100G","25G","25G","10G","10G","50G","25G","25G","10G","10G","10G","25G","25G","25G","25G","25G","25G","25G","25G","100G","50G","50G","50G","50G","50G","50G","50G","50G","25G","100G","100G","100G","100G","50G","50G","50G","50G","50G","100G","32G","10G","12.5G"],
   "FiberType":["MM","SM","SM","MM","SM","SM","MM","MM","MM","SM","MM\nSM","MM\nSM","SM","SM","SM","SM","MM","SM","SM","SM","SM","SM","MM","MM","MM","MM","MM","SM","SM","SM","MM","MM","","SM","SM","SM","SM","SM","MM","MM","SM","SM","SM","SM","MM","MM","MM","MM","MM","SM","SM","SM","SM","SM","SM","SM","MM","MM","MM","MM","MM"],
   "Distance":["","40km","10km","","500m","10km","OM3 - 100m\nOM4 - 150m","OM3 - 300m\nOM4 - 400m","OM3 - 100m\nOM4 - 150m","40km","OM4 - 160m\nSM - 10km","OM4 - 160m\nSM - 10km","10km","2km","2 km","2km","100m","500m","500m","2km","40km","10km","150m","300m","100m","200m - OM3\n400m - OM4","","2km","10km","40km","OM3 - 70m\nOM4 - 100m","OM3 - 70m\nOM4 - 100m","80km","500m","2km","500m","10km","2km","","OM3 - 70m\nOM4 - 100m","500m","2km","10km","10km","100m","100m","100m","OM3 - 70m\nOM4 - 100m","","500m","2km","2km","2km","2km","10km","40km","100m","30m","100m","100m","100m"],
   "WDM":["no","no","no","","no","yes","no","no","yes","yes","yes","yes","no","no","no","no","no","no","yes","no","yes","yes","no","no","no","no","no","yes","yes","yes","yes","yes","yes","no","yes","yes","yes","yes","","no","no","yes","yes","yes","yes, 4 µ each lane","no","no","no","yes","no","no","yes","yes","yes","yes","yes","yes, 4 µ each lane","yes","no","no","no"],
   "Standard":["","IEEE 802.3cc","IEEE 802.3cc","IEEE 802.3by","proprietary","IEEE 802.3ba","IEEE 802.3ba","proprietary","proprietary","IEEE 802.3bm","proprietary","proprietary","proprietary","IEEE 802.3bg","IEEE 802.3cd","IEEE 802.3cd","IEEE 802.3cd","IEEE 802.3bs","IEEE 802.3cd","proprietary","IEEE 802.3ba","IEEE 802.3ba","IEEE 802.3ba","proprietary","IEEE 802.3cd","proprietary","IEEE 802.3bm","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","proprietary","","IEEE 802.3cd","IEEE 802.3bs","IEEE 802.3bs","IEEE 802.3bs","IEEE 802.3cn","","IEEE 802.3cm","IEEE 802.3cm","IEEE 802.3bs","IEEE 802.3cm","IEEE 802.3bs","proprietary","proprietary","proprietary","IEEE 802.3bs","IEEE 802.3bs","IEEE 802.3bs","","","proprietary","proprietary","proprietary"]
}
//constructor for transceiver
function Transceiver(i,S,Q){
  //converted data from Excel spreadsheet
  // if nothing is provided
  if(i!=null){
      this.RowNumber=i
      this.ShapeName=JSONdata.ShapeName[i]
      this.PhysicalInterface=JSONdata.PhysicalInterface[i]
      this.TotalSpeed=JSONdata.TotalSpeed[i]
      this.Technology=JSONdata.Technology[i]
      this.Duplex=JSONdata.Duplex[i]
      this.ConnectorType=JSONdata.ConnectorType[i]
      this.BreakoutOption=JSONdata.BreakoutOption[i]
      this.NumberOfLanes=JSONdata.NumberOfLanes[i]
      this.SingleLaneSpeed=JSONdata.SingleLaneSpeed[i]
      this.FiberType=JSONdata.FiberType[i]
      this.Distance=JSONdata.Distance[i]
      this.WDM=JSONdata.WDM[i]
      this.Standard=JSONdata.Standard[i]
      this.Quantity=Q //how many transceivers in a group
      this.Side = S //which side to show - left - A or right - B
  } else {
      this.RowNumber=null
      this.ShapeName=""
      this.PhysicalInterface=""
      this.TotalSpeed=""
      this.Technology=""
      this.Duplex=""
      this.ConnectorType=""
      this.BreakoutOption=""
      this.NumberOfLanes=""
      this.SingleLaneSpeed=""
      this.FiberType=""
      this.Distance=""
      this.WDM=""
      this.Standard=""
  }
};
//constructor for Selector tool
function FOSelector() {
  this.Types = {
    Technology: JSONdata.Technology,
    ConnectorType: JSONdata.ConnectorType,
    Related: JSONdata.Related,
    RelatedConnectorType: JSONdata.RelatedConnectorType,
    RelatedPolarity: JSONdata.RelatedPolarityType,
    Quantity: JSONdata.Quantity
               };
  //console.log(this.Types)
    this.AllPolarities = MergeAndSplit(JSONdata.RelatedPolarityType);
  this.PolarityS="PP";
  this.StepsT = ["Step #1. To start selector you need to pick up the side A transceiver",
                 "Transceiver A selected",
                 "Step #2. Now click on the second transceiver and pick up the matching transceiver",
                 "Transceiver B selected",
                 "Check the fiber allocation and recommended versions of cabling"
                ];
  this.CurrStep = 4;
  
  this.Selected = {
    sideA: new Transceiver(57,"A",1),
    sideB: new Transceiver(38,"B",4),
  };  
var obj = this;
var paper = Snap("#Selector");
var p = null;  //this will be 'draw'
var pX = 0; 
var pY = 0;
var pW = 900;
var pH = 600; 
var pG = 10;

this.Draw = function(){ 
  //console.log(this.CurrStep)
    DeleteById("draw")
    DeleteById("showTrSelector");
    p = paper.g().attr({id:"draw"});
    p.rect(pX,pY,pW,pH).attr({class:"st5"});
    // Draws the top
    this.Top = function(text){
      let top=p.group();
      top
        .rect(pX+pG,pY+pG,pW-2*pG,5*pG,5)
        .attr({class:"st2"})
      top
        .text(pX+5*pG,pY+4.5*pG,text)
        .attr({class:"Legend1"})
      //load the refresh button
      let refresh = top.g().attr({id:"refresh", fill:"white", transform:"scale("+0.6+"), translate("+(700)+",5)", cursor:"pointer"});
      Snap.load("https://dl.dropboxusercontent.com/s/4ecr0u0bx37quac/Refresh.svg", function (loadedFragment) {refresh.append(loadedFragment);})
      let title=Snap.parse('<title>Press here to restart the selector</title>')
          refresh.append(title)
      refresh.click(function (event){
        obj.CurrStep=0;
        obj.Selected = {sideA:new Transceiver(null),sideB:new Transceiver(null),}
        obj.Draw()
        //console.log("test")
      })
    };
    //Annotation text
    this.Steps = function(text){
      let steps=p.group();
      steps.rect(pX+pG,pY+7*pG,pW-2*pG,5*pG,5).attr({class:"st2"});
      steps.text(pX+5*pG,pY+10*pG,text).attr({class:"Legend2"}) 
    };
  //Left transceiver rectangle
    this.Left = function(){
      let left = p.group().attr({id:"Left"});
          left.rect(pX+pG,pY+13*pG,(pW-3*pG)/2,(pW-3*pG)/3,5).attr({class:"st2"});
          
      if(this.CurrStep==0){
        //only if first step
        left.text(pX+7*pG,pY+27*pG,"Transceiver side A").attr({class:"Legend2",fontSize:40})
        left.attr({class:"selected"});
        left.click(function(event){
          obj.ShowTrSelector("none");
        })
      
      } else if(this.CurrStep>=1) {
        let SmartShapeLeft = new FOTransceiverSmartShape(obj.Selected.sideA,left,pX+pG,pY+13*pG,(pW-3*pG)/2);
        SmartShapeLeft.Draw();
      };
    };
  //Right transceiver rectangle
    this.Right = function(){
      let right = p.group().attr({id:"Right"});;
      right.rect(pX+(pW-3*pG)/2+2*pG,pY+13*pG,(pW-3*pG)/2,(pW-3*pG)/3,5).attr({class:"st2"})
      if(this.CurrStep==2){
        //only if second step
        right.text(pX+(pW-3*pG)/2+8*pG,pY+27*pG,"Transceiver side B").attr({class:"Legend2",fontSize:40})
        right.attr({class:"selected"});
        right.click(function (event) {obj.ShowTrSelector("yes")});
        
      } else if (this.CurrStep>=3) {
         let SmartShapeRight = new FOTransceiverSmartShape(obj.Selected.sideB,right,pX+(pW-3*pG)/2+2*pG,pY+13*pG,(pW-3*pG)/2);
        SmartShapeRight.Draw();
        // obj.DrawTransceiver(right,obj.Selected.sideB,pX+(pW-3*pG)/2+2*pG,pY+13*pG,(pW-3*pG)/2,30*pG,"Right")
      };
      
    };
  
    //builds the polarity behaviour
    this.Polarity = function(){
      if(this.CurrStep>=4){
      //group with rectangle
      let polarity = p.group().attr({id:"Polarity"});
            polarity
              .rect(pX+pG,pY+14*pG+(pW-3*pG)/3,pW-2*pG,16*pG,5)
              .attr({class:"st2"})
            polarity
              .text(pX+3*pG,pY+17*pG+(pW-3*pG)/3,"Lane assignment scheme")
              .attr({class:"Legend2"})
            polarity
              .text(pX+3*pG,pY+19*pG+(pW-3*pG)/3,"according Huber+Suhner")
              .attr({class:"Legend2"})
        //builds the group of polarity types icons
            polarity
              .rect(pX+pG+300,pY+15*pG+(pW-3*pG)/3,pW-300-3*pG,5*pG,5)
              .attr({id:"Polarity group", class:"st3"});
           polarity
              .rect(pX+2*pG,pY+21*pG+(pW-3*pG)/3,pW-4*pG,3*pG,5)
              .attr({id:"Lanes group", class:"st3"});
          polarity
              .rect(pX+2*pG,pY+25*pG+(pW-3*pG)/3,pW-4*pG,4*pG,5)
              .attr({id:"Cabling proposals", class:"st3"});
        //function drawTextIcon draws group with icons with polarity text and returns the group(object) which can be appended to the polarity group
        //arguments - paper, array with Texts, group width and group height, and the selected object
        let polIconGroup = drawTextIcon(p,obj.AllPolarities,pW-300-3*pG,5*pG,obj.PolarityS);
            polIconGroup.transform("translate("+(pX+pG+300)+","+(pY+15*pG+(pW-3*pG)/3)+")");
            polarity.append(polIconGroup);


      //1. Get the coordinates of circles from both sides
      //2. Check the polarity
      //3. Draw lines according polarity
      //4.
      //FOTSS_bod_gro_A 
      //FOTSS_bod_gr2_A 
      //Obj_A_0 
      //Obj_A_0_group
      //Obj_A_0_group_Pin_1

      let coordArrA=[],coordArrB=[], numberLanesA = obj.Selected.sideA.NumberOfLanes, numberLanesB = obj.Selected.sideB.NumberOfLanes,quantity=obj.Selected.sideB.Quantity;
       //get ellipse(pins) coordinates
      coordArrA = getRelativeEllipseCoordinates("A",numberLanesA*2);  
      coordArrB = ReversePolarityArray(getRelativeEllipseCoordinates("B",numberLanesB*2,quantity),obj.PolarityS,numberLanesA*2);        
        //draw paths
        let path,path_draw,direction,lane_text,laneArr=[];
        for(let i=0;i<=coordArrA.length-1;i++){
          lane_text = coordArrA[i][2].substr(0,2);
          laneArr[i]= coordArrA[i][2] + "_"+coordArrB[i][2]
          path = Path_opp(coordArrA[i][0],coordArrA[i][1],coordArrB[i][0],coordArrB[i][1],50);    
          if(lane_text=="Tx"){direction="left"}else{direction="right"};
          path_draw = drawAnimatedPath(p,path,direction,"lightgrey","Lane_"+laneArr[i]);
          polarity.append(path_draw);
        }
        //draws lane icons
         let lanesGroup = drawTextIcon2(p,laneArr,pW-4*pG,3*pG);
          lanesGroup.transform("translate("+(pX+2*pG)+","+(pY+21*pG+(pW-3*pG)/3)+")");
         polarity.append(lanesGroup);
        
        //.rect(pX+2*pG,pY+25*pG+(pW-3*pG)/3,pW-4*pG,4*pG,5)
        let cablingTypes = drawTextIcon3(p,['direct attach','direct connect','inter connect','cross connect'],pW-4*pG,4*pG,openPNG);
          cablingTypes.transform("translate("+(pX+2*pG)+","+(pY+25*pG+(pW-3*pG)/3)+")");
         polarity.append(cablingTypes);
      }
    }
  
      this.Top("FO cabling selector")
      this.Steps(this.StepsT[this.CurrStep])
      this.Left()
      this.Right()
      this.Polarity()
}
//function showing the transciever selector page
this.ShowTrSelector = function(sideA){
    DeleteById("showTrSelector");
    let trTeArr = [], trReArr = [], trQuantity=[], trPoArr=[];
  //what array is taken
  //trTeArr = transceiver technology array, trReArr = transceiver's related connector types
    if(sideA=="none"){
      trTeArr = obj.Types.Technology;
      trReArr = obj.Types.ConnectorType;
      trQuantity = [1]
                     } else {
      trTeArr = obj.Types.Related[obj.Selected.sideA.RowNumber].split(";")
      trReArr = obj.Types.RelatedConnectorType[obj.Selected.sideA.RowNumber].split(";")
      trQuantity = obj.Types.Quantity[obj.Selected.sideA.RowNumber].split(";")
      trPoArr = obj.Types.RelatedPolarity[obj.Selected.sideA.RowNumber].split(";")
                     }
  // how many columns of icons - qC
    let qC = getQuantityPerRow(trTeArr.length,pW-1.5*pG,pH-1.5*pG,pG); //TODO - selector - scale
    let tW = (pW-(5+qC-1)*pG)/qC; //calculation of transceiver width icon. width=height
  
    let selW = paper.g().attr({id:"showTrSelector"});
  //background rectangle
    selW.rect(pX+0.5*pG,pY+0.5*pG,pW-1.5*pG,pH-1.5*pG,5).attr({class:"st5"});
  //group where the content is stored
    let selC = selW.g().attr({id:"showTrSelectorContent"})
  //When side A is clicked
      // creates a shape of every transceiver
      for(var iii=0;iii<trTeArr.length;iii++){
        //x and y coordinate of shapes, tS - text scale
        let tS=0.8;
        let xx=pX+2*pG+((iii % qC)*(tW+pG));
        let yy=pY+2*pG+(iii-(iii%qC))/qC*(tW+pG);
        // icon - group of some shapes;
        let selTr = selC.group().attr({id:"icon"+iii, transform:"translate("+xx+","+yy+ ")",class:"hover"});
        //rectangle - border
        selTr.rect(5,5,tW,tW,5).attr({class:"st7",class:"trIcon"});
        //text - heading of the transceiver
        selTr.text(10,20,trTeArr[iii]).attr({class:"trText",transform:"scale("+tS+")"});
        let title = Snap.parse('<title>Pick up '+ trTeArr[iii] +' transceiver</title>') //tooltip when the cursor is over the icon
       //select what physical interface is
        switch(trReArr[iii].substr(0,2)){ 
          case "LC":
           selTr
             .append(Duplex(paper,20,25,trReArr[iii],"",tW/127*.5,1,1).obj)
             .append(title)
         break;
         case "MP":
           selTr
              .append(MPO(paper,18,18,"","A",trReArr[iii],tW/192*0.9,1).obj)
              .append(title)
         break;
            selTr.appendTo(selC)
       };                                  
        //when user clicks on icon - then the shape is selected and the FOselector re-draws
        //TODO add some animation effects here
	      let trNumber=iii;
        selTr.click(function (event,trNumber){
	
          if(sideA=="none"){
            let newTr = new Transceiver(trNumber);
            newTr.Quantity=trQuantity[0];
            newTr.Side="A";
            obj.Selected.sideA = newTr
            obj.CurrStep++;
          } else {
            let rowNumber = vLookup(trTeArr[trNumber],obj.Types.Technology);
            if(rowNumber==null){console.log("The thansceiver "+trTeArr[trNumber]+" cannot be found in the list"); obj.CurrStep=0; obj.Draw(); return null}
            let newTr = new Transceiver(rowNumber); 
            newTr.Quantity=trQuantity[trNumber];
            newTr.Side="B";
            obj.Selected.sideB = newTr;
            obj.CurrStep++;
            obj.PolarityS = trPoArr[trNumber];
          }
        obj.CurrStep++;
        obj.Draw();
      })
        selTr.hover(function (event) {
          //let hovTr = new Transceiver(i);
          //console.log (hovTr.TotalSpeed)
      })
      }
       
  }
}

//main code
let FOS1 = new FOSelector();
FOS1.Draw();

//helpful functions


//lookup = searches if a is inside array
function vLookup(a,b){for(var i=0;i<(b.length);i++){if (a==b[i]) {return i}}}

//Deletes the element by ID
function DeleteById(id){
	if(id!=""){
let x = document.getElementById(id);
	//if(x!=null){x.remove()}- was replaced by
	if(x!=null){x.parentNode.removeChild(x);}
} 
}	

//function returns quantity of icons in a row in a given shape which has W width and H height and g margin between icons
function getQuantityPerRow(Q,W,H,g){
  let foundFirst = false,foundQ,i=1,qW,qH;
  do{
    qW = Math.floor(W/(i+g));
    qH = Math.floor(H/(i+g));
     if ((qW*qH)<Q) {
      foundFirst = true;
      foundQ=qW+1;
    };
    i=i+2;
  }
  while (foundFirst==false);
  return foundQ
}

//Determines coordinates and returns the array
//Id of the ellipse must match the mask that defined in this function
function getRelativeEllipseCoordinates(side,numberLanes,quantity){
  //console.log("side " +side+ " number lanes "+numberLanes + " quantity "+ quantity)
    if(quantity==undefined){quantity=1}
    let pos = document.getElementById("draw");
    let posH = pos.getBoundingClientRect(); //this is the position of the main group
    let scale = posH.width/900; //because viewport is 900(without scale) but based on a browser it can take various dimensions (responsive), so here it determines the scale of the main group
  let offsetY,offsetX;
    
      offsetY = getBCR("y",posH);//.y; //calculates the offset for the group in the browser
      offsetX = getBCR("x",posH);
      let result = [];
      let elT,el,elLane,elBB,X,Y,m;
  for(let y=0;y<=quantity-1;y++){
      m=0;
    for(let u=0;u<=numberLanes-1;u++){
      elT = "Obj_"+side+"_"+y+"_group_Pin_"+(u+m) //builds the id of the Pin
      el = document.getElementById(elT); // takes the element containing id
      if(el==null){console.log("Cannot get element by ID: "+elT); return result} //if such element not exists then function returns result
      elLane = el.getAttribute("lane"); //takes the attribute lane from element
      //console.log(el.getAttribute("lane"))
      if(elLane==null){ //if element attribute not exists
            do {
              elT = "Obj_"+side+"_"+y+"_group_Pin_"+(u+m) //this takes the id of the Pin
              el = document.getElementById(elT);
              if(el!=null){elLane = el.getAttribute("lane")}
              m++;
              if(m>32){console.log("looks like the transceiver element created wrongly"); return result}
            }
            while(elLane==null); //checks every next id of the Pin until he finds the next one with attribute lane in it
            m--;
            elBB = el.getBoundingClientRect();
            X = (getBCR("x",elBB)-offsetX+elBB.width/2)/scale;
            Y = (getBCR("y",elBB)-offsetY+elBB.height/2)/scale;
            result[u+y*numberLanes]=[X,Y,elLane]
      } else {
        elBB = el.getBoundingClientRect();
        X = (getBCR("x",elBB)-offsetX+elBB.width/2)/scale;
        Y = (getBCR("y",elBB)-offsetY+elBB.height/2)/scale;
        result[u+y*numberLanes]=[X,Y,elLane]     
    }
    }
  }
  return result;
}

//builds the path which can be applied as d attribute to path function
function Path_opp(x1,y1,x2,y2,angle){
	let 
		X = 0.5*(x1+x2)-0.5*(y1-y2)/Math.tan(angle*Math.PI/180),
		Y = 0.5*(y1+y2)-0.5*(x1-x2)*Math.tan(angle*Math.PI/180),
		path = "M "+x1+","+y1+" Q "+X+","+Y+","+x2+","+y2;
		return path
}

//function builds the polarity array
//takes the json as a list of various polarity types and then based on that builds the list of unique fields
function MergeAndSplit(obj){
  let arr = ""
  for(let i=0;i<=obj.length-2;i++){
      arr=arr+obj[i]+";"
  }
  //last element is added without semicolon
  arr=arr+obj[obj.length-1];
   let retArr = arr.split(";").filter(function (v, i, a) { a.indexOf(v) === i});
//console.log (retArr);
  return retArr;
}

//function that reverses the array based on polarity
//takes the array of coordinates and returns the array of coordinates but re-arranged based on what polarity is
//TODO add B:2-2
function ReversePolarityArray(arr1,polarity,number){
  let arr2=[],arrPol;
  switch(polarity){
    case "AP":
      arrPol = [1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22]
    break;
    case "NP":
      switch(number){
        case 8:
          arrPol = [1,3,5,7,6,4,2,0]
          break;
        case 4:
          arrPol = [1,3,2,0]
          break;
      }
    break;
    case "B":
      switch(number){
        case 4:
          arrPol = [3,2,1,0]
        break;
        case 8:
          arrPol = [7,6,5,4,3,2,1,0]
        break;
        case 16:
          arrPol = [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
        break;
      }
    break;
    case "A:2-2":
      switch(number){
        case 20:
          arrPol = [10,11,12,13,14,15,16,17,18,19,0,1,2,3,4,5,6,7,8,9]
        break;
        case 24:
          arrPol = [12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6,7,8,9,10,11]
        break;
      }
    break;  
    case "TT":
      switch(number){
        case 32:
          arrPol = [28,29,30,31,20,21,22,23,12,13,14,15,4,5,6,7,27,26,25,24,19,18,17,16,11,10,9,8,3,2,1,0]
        break;
      }
      break;
    case "KK":
      switch(number){
        case 16:
          arrPol = [1,3,5,7,6,4,2,0,9,11,13,15,14,12,10,8]
        break;
      }
      break; 
      case "R1":
      switch(number){
        case 20:
          arrPol = [18,16,14,12,10,8,6,4,2,0,19,17,15,13,11,9,7,5,3,1]
        break;
        case 24:
          arrPol = [22,20,18,16,14,12,10,8,6,4,2,0,23,21,19,17,15,13,11,9,7,5,3,1]
        break;
      }
      break; 
      case "YY":
        switch(number){
          case 24:
            arrPol = [19,18,17,16,11,10,9,8,3,2,1,0,20,21,22,23,12,13,14,15,4,5,6,7]
          break;
      }
      case "XX":
        switch(number){
          case 16:
            arrPol = [7,6,5,4,15,14,13,12,11,10,9,8,3,2,1,0]
          break;
      }      
      break; 
      case "PP":
        switch(number){
          case 16:
            arrPol = [3,2,7,6,11,10,15,14,13,12,9,8,5,4,1,0]
          break;
      }      
      break; 
  }
  for(let i=0;i<=arr1.length-1;i++){
    arr2[i]=arr1[arrPol[i]]
  }
  return arr2
}

// Draws polarity icons
function drawTextIcon(p,arr,W,H,selected){
  let m=4; //m - margin,spacing between icons
  let cW = W-2*m; //calculated width of useable width
  let iW = (cW-(arr.length-1)*m)/arr.length; //icon width
  let iH = H-2*m; //icon height
  let group = p.group().attr({id: "Polarity icons",class:'st3'});
  let icon_gr,icon,iconText,iconTextBB,iconTextBB_w,iconTextBB_h,sc;
  for (let i=0;i<=arr.length-1;i++){
    let _class; //special formatting for the polarity which is selected
      (arr[i]==selected)?(_class="st5"):(_class="st2") 
        icon = p.rect(0,0,iW,iW,5).attr({class:_class});
        iconText = p.text(0,0,arr[i]).attr({id:"Icon_text_"+arr[i],class:"Legend2"});
        iconTextBB = iconText.getBBox();
        iconTextBB_w = (iW-2*m)/iconTextBB.width;
        iconTextBB_h = (iH-2*m)/iconTextBB.height;
        sc = Math.min(iconTextBB_w,iconTextBB_h);
        iconText.transform("translate("+((iW-iconTextBB.width*sc)/2)+","+(iH-m-(iH-iconTextBB.height*sc)/2)+"), scale("+(sc)+")" );
        icon_gr = p.g(icon,iconText).attr({id:"Icon_"+arr[i]});
        icon_gr.transform("translate("+(m+i*(iW+m))+","+(H-iH-m)+")")
        group.append(icon_gr);
        };
  return group
}

// Draws polarity icons
function drawTextIcon2(p,arr,W,H,selected){
  let m=4; //m - margin,spacing between icons
  let cW = W-2*m; //calculated width of useable width
  let iH = H-2*m; //calculated width of useable width
  let iW = (cW-(arr.length-1)*m)/arr.length; //icon width
  let group = p.group().attr({id: "Polarity icons"});
  let icon_gr,icon,iconText,iconTextBB,iconTextBB_w,iconTextBB_h,sc;
  for (let i=0;i<=arr.length-1;i++){
    let _class="st5"; //special formatting for the polarity which is selected
      //(arr[i]==selected)?(_class="st5"):(_class="st2") 
        icon = p.rect(0,0,iW,iH,5).attr({class:_class,id:"LaneT_"+arr[i]});
        iconText = p.text(0,0,arr[i]).attr({id:"Icon_text_"+arr[i],class:"Legend2"});
        iconTextBB = iconText.getBBox();
        iconTextBB_w = (iW-2*m)/iconTextBB.width;
        iconTextBB_h = (iH-2*m)/iconTextBB.height;
        sc = Math.min(iconTextBB_w,iconTextBB_h);
        iconText.transform("translate("+((iW-iconTextBB.width*sc)/2)+","+(iH-m-(iH-iconTextBB.height*sc)/2)+"), scale("+(sc)+")" );
        icon_gr = p.g(icon,iconText).attr({id:"Icon_"+arr[i],cursor:"pointer"});
        let laneStr = arr[i].split('_');
        let title = Snap.parse('<title>Side A: '+laneStr[0]+', side B: '+ laneStr[1]+ '</title>') //tooltip when the cursor is over the icon
       //select what physical interface is
        icon_gr.append(title)
        icon_gr
          .transform("translate("+(m+i*(iW+m))+","+(H-iH-m)+")")
          .click(function (){
            let el = Snap('#Lane_'+arr[i]);
            let el2 = Snap('#LaneT_'+arr[i]);
            if(el.attr().show=="true"){
              el.attr({opacity:0,show:"false"});
              el2.attr({class:"st3"})
            } else {
              el.attr({opacity:1,show:"true"});
              el2.attr({class:"st5"})
            }
        });
        group.append(icon_gr);
        };
  return group
}

//function draws animated paths and returns the path
function drawAnimatedPath(p,d,direction,strokeColor,id){
  let speed=2;
  let path = p.path().attr({d:d, stroke:strokeColor, fill:'none',strokeDasharray: speed,id:id,show:"true"});
  // Animation for dotted lines
function animation(el,direction) {
  let d=speed*2,d1=0;
  if (direction=="left") {d=0;d1=speed*2}
  el.animate({strokeDashoffset:d},200,mina.linear,function(){
    // window.setTimeout((null),0)
    el.attr({strokeDashoffset: d1})
    animation(el,direction)
  })
};
  animation(path,direction);
  return path
}

//function returns client bounding rectangle - for chrome and IE11
function getBCR(coord,el){
  if(coord=="x"){ 
  return (el.x==undefined)?(el.left):(el.x)
  } else if (coord=="y"){
    return (el.y==undefined)?(el.top):(el.y)
  }
}

// Draws text icons which fit the given rectangle
// p - Snap paper
// arr - array with text
// W and H - width and height of rectangle where icons must fit, argument m inside function determines margins
// selected ???
// returns the snap element which can be appended to a group
function drawTextIcon3(p,arr,W,H,clickCallback){
  let m=4; //m - margin,spacing between icons
  let cW = W-2*m; //calculated width of useable width
  let iH = H-2*m; //calculated width of useable height
  let iW = (cW-(arr.length-1)*m)/arr.length; //icon widths
  //draws the group
  let group = p.group().attr({id: "Cabling icons"});
  let icon_gr,icon,iconText,iconTextBB,iconTextBB_w,iconTextBB_h,sc;
  for (let i=0;i<=arr.length-1;i++){
    let _class="st3"; //special formatting for the polarity which is selected
      //(arr[i]==selected)?(_class="st5"):(_class="st2") 
        icon = p.rect(0,0,iW,iH,5).attr({id:"CablingT_"+arr[i]});
        iconText = p.text(0,0,arr[i]).attr({id:"Cabling_"+arr[i],class:'cablingIcon-text'});
        iconTextBB = iconText.getBBox();
        iconTextBB_w = (iW-2*m)/iconTextBB.width;
        iconTextBB_h = (iH-2*m)/iconTextBB.height;
        sc = Math.min(iconTextBB_w,iconTextBB_h);
        iconText.transform("translate("+((iW-iconTextBB.width*sc)/2)+","+(iH-m-(iH-iconTextBB.height*sc)/2)+"), scale("+(sc)+")" );
        icon_gr = p.g(icon,iconText).attr({id:"Icon_"+arr[i],class:'cablingIcon'});
       //  let laneStr = arr[i].split('_');
       //  let title = Snap.parse('<title>Side A: '+laneStr[0]+', side B: '+ laneStr[1]+ '</title>') //tooltip when the cursor is over the icon
       // //select what physical interface is
       //  icon_gr.append(title)
        icon_gr
          .transform("translate("+(m+i*(iW+m))+","+(H-iH-m)+")")
          .click(function () {clickCallback(arr[i])});
        group.append(icon_gr);
        };
  return group
}
//opens png file and adds event to close it
function openPNG(el){
  p= Snap('#Selector');
  console.log(el)
  let img = p.image('https://dummyimage.com/900x600/ccdbe9/000000.png&text='+el,10,10,880,580).attr({cursor:'pointer'});
  img.append(Snap.parse('<title>Click on image to close it</title>'))
  img.click(function (){img.remove()})
}
